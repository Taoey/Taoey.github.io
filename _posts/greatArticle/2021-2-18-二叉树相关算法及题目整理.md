---
layout: post
title: leetcode二叉树相关算法及题目整理
categories: [leetcode,算法]
description: leetcode二叉树相关算法及题目整理
keywords: leetcode,二叉树
---

二叉树自定义栈前中后序遍历，层序遍历，N叉树遍历，打印二叉树所有路径


## 1、二叉树前中后遍历


二叉树前中后遍历推荐使用自定义栈进行解题，不要使用递归解题，栈中的元素没有null元素

中序遍历思路：

- 先将全部的左子节点入栈
- 弹出栈顶元素item
- 指针cur指向item右子节点



前序或后序遍历思路：

- 栈顶节点弹栈，把当点节点value加入到result中
- 左右子节点分别入栈，注意出栈顺序需要保证对应的遍历顺序（前序入栈：中左右->先右后左；后序入栈：左右中->先右后左）

### 二叉树中序遍历

leetcode-94

```python
from typing import List
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result, stack = [], []
        cur = root
        while stack or cur:
            while cur:
                stack.append(cur)
                cur = cur.left
            item = stack.pop()
            result.append(item.val)
            cur = item.right
        return result
```



### 二叉树前序遍历

leetcode-144

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Definition for a binary tree node.
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []

        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            # 入栈先右后左，保证出栈时的顺序为先左后右
            if item.right: stack.append(item.right)
            if item.left: stack.append(item.left)
        return result

if __name__ == '__main__':
    A = TreeNode(1)
    B = TreeNode(2)
    C = TreeNode(3)

    A.left = B
    A.right= C

    s = Solution()
    result = s.preorderTraversal(A)
    print(result)
```



### 二叉树后序遍历

leetcode-145

```python
from typing import List


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            if item.left: stack.append(item.left)
            if item.right: stack.append(item.right)
        return result[::-1]
```



## 2、N叉树的前序遍历

和二叉树的前序遍历思路基本类似，只是在添加子节点部分略有修改

```python
# Definition for a Node.
from typing import List


class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        if not root: return []
        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            if item.children: stack.extend(item.children[::-1])

        return result
```



## 3、二叉树的所有路径

```python
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        result = []

        def dfs(root, path):
            if root.left is None and root.right is None:  # 子节点
                path += str(root.val)
                result.append(path)

            else:
                path += str(root.val)+"->"
                if root.left:dfs(root.left,path)
                if root.right:dfs(root.right,path)

        if root:
            dfs(root, "")
        return result
```



## 4、面试题55 - I. 二叉树的深度（层序遍历）
原题地址：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/


```
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

解题思路：

利用广度优先遍历思想，进行二叉树的层序遍历，每遍历一层深度+1，这道题的确不是很难leetcode上标注的为easy

```python
import queue

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root: return 0
        dep = 0
        q = queue.Queue()
        q.put(root)
        while q.empty() is False:
            nodes_len = q.qsize()
            for i in range(nodes_len):
                node = q.get()
                if node.left: q.put(node.left)
                if node.right: q.put(node.right)
            dep += 1
        return dep
```

