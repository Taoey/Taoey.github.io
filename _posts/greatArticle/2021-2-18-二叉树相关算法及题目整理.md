---
layout: post
title: leetcode二叉树相关算法及题目整理
categories: [leetcode,算法]
description: leetcode二叉树相关算法及题目整理
keywords: leetcode,二叉树
---

二叉树自定义栈前中后序遍历，N叉树遍历，打印二叉树所有路径


## 1、二叉树前中后遍历


二叉树前中后遍历推荐使用自定义栈进行解题，不要使用递归解题

中序遍历思路：

- 先将全部的左子节点入栈
- 弹出栈顶元素item
- 指针cur指向item右子节点



前序或后序遍历思路：

- 栈顶节点弹栈，把当点节点value加入到result中
- 左右子节点分别入栈，注意出栈顺序需要保证对应的遍历顺序（前序入栈：中左右->先右后左；后序入栈：左右中->先右后左）

### 二叉树中序遍历

leetcode-94

```python
from typing import List
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result, stack = [], []
        cur = root
        while stack or cur:
            while cur:
                stack.append(cur)
                cur = cur.left
            item = stack.pop()
            result.append(item.val)
            cur = item.right
        return result
```



### 二叉树前序遍历

leetcode-144

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Definition for a binary tree node.
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []

        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            # 入栈先右后左，保证出栈时的顺序为先左后右
            if item.right: stack.append(item.right)
            if item.left: stack.append(item.left)
        return result

if __name__ == '__main__':
    A = TreeNode(1)
    B = TreeNode(2)
    C = TreeNode(3)

    A.left = B
    A.right= C

    s = Solution()
    result = s.preorderTraversal(A)
    print(result)
```



### 二叉树后序遍历

leetcode-145

```python
from typing import List


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            if item.left: stack.append(item.left)
            if item.right: stack.append(item.right)
        return result[::-1]
```



## 2、N叉树的前序遍历

```python
# Definition for a Node.
from typing import List


class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        if not root: return []
        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            if item.children: stack.extend(item.children[::-1])

        return result
```



## 3、二叉树的所有路径

```python
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        result = []

        def dfs(root, path):
            if root.left is None and root.right is None:  # 子节点
                path += str(root.val)
                result.append(path)

            else:
                path += str(root.val)+"->"
                if root.left:dfs(root.left,path)
                if root.right:dfs(root.right,path)

        if root:
            dfs(root, "")
        return result
```