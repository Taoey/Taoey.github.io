---
layout: post
title: leetcode二叉树相关算法及题目整理
categories: [leetcode,算法]
description: leetcode二叉树相关算法及题目整理
keywords: leetcode,二叉树
---

二叉树自定义栈前中后序遍历，层序遍历，N叉树遍历，打印二叉树所有路径


## 1、二叉树前中后遍历


二叉树前中后遍历推荐使用自定义栈进行解题，不要使用递归解题，栈中的元素没有null元素

中序遍历思路：

- 先将全部的左子节点入栈
- 弹出栈顶元素item
- 指针cur指向item右子节点



前序或后序遍历思路：

- 栈顶节点弹栈，把当点节点value加入到result中
- 左右子节点分别入栈，注意出栈顺序需要保证对应的遍历顺序（前序入栈：中左右->先右后左；后序入栈：左右中->先右后左）

### 二叉树中序遍历

leetcode-94

```python
from typing import List
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result, stack = [], []
        cur = root
        while stack or cur:
            while cur:
                stack.append(cur)
                cur = cur.left
            item = stack.pop()
            result.append(item.val)
            cur = item.right
        return result
```



### 二叉树前序遍历

leetcode-144

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Definition for a binary tree node.
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []

        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            # 入栈先右后左，保证出栈时的顺序为先左后右
            if item.right: stack.append(item.right)
            if item.left: stack.append(item.left)
        return result

if __name__ == '__main__':
    A = TreeNode(1)
    B = TreeNode(2)
    C = TreeNode(3)

    A.left = B
    A.right= C

    s = Solution()
    result = s.preorderTraversal(A)
    print(result)
```



### 二叉树后序遍历

leetcode-145

```python
from typing import List


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            if item.left: stack.append(item.left)
            if item.right: stack.append(item.right)
        return result[::-1]
```



## 2、N叉树的前序遍历

和二叉树的前序遍历思路基本类似，只是在添加子节点部分略有修改

```python
# Definition for a Node.
from typing import List


class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        if not root: return []
        stack, result = [root], []

        while stack:
            item = stack.pop()
            result.append(item.val)
            if item.children: stack.extend(item.children[::-1])

        return result
```



## 3、二叉树的所有路径

```python
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        result = []

        def dfs(root, path):
            if root.left is None and root.right is None:  # 子节点
                path += str(root.val)
                result.append(path)

            else:
                path += str(root.val)+"->"
                if root.left:dfs(root.left,path)
                if root.right:dfs(root.right,path)

        if root:
            dfs(root, "")
        return result
```



## 4、二叉树的深度（层序遍历）
原题地址：[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)


```
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

解题思路：

利用广度优先遍历思想，进行二叉树的层序遍历，每遍历一层深度+1，这道题的确不是很难leetcode上标注的为easy

```python
import queue

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root: return 0
        dep = 0
        q = queue.Queue()
        q.put(root)
        while q.empty() is False:
            nodes_len = q.qsize()
            for i in range(nodes_len):
                node = q.get()
                if node.left: q.put(node.left)
                if node.right: q.put(node.right)
            dep += 1
        return dep
```

## 5、平衡二叉树

原题地址：[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

```
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。
如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 
 示例 1: 
 给定二叉树 [3,9,20,null,null,15,7] 
     3
   / \
  9  20
    /  \
   15   7 

 返回 true 。 
示例 2: 
 给定二叉树 [1,2,2,3,3,null,null,4,4] 
        1
      / \
     2   2
    / \
   3   3
  / \
 4   4
 返回 false 。 
 限制：
 1 <= 树的结点个数 <= 10000
 注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/ 
```

解题思路：

二叉树深度的判断和二叉树遍历的结合体，总体思路就是，判断每一个节点的左右子树的最大深度只差不超过1，空节点的深度为0

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def dfs(cur):
            # 获取当前节点的左右子树高度
            left_dep, right_dep = self.maxDepth(cur.left), self.maxDepth(cur.right)
            # 判断左子树是否平衡
            left_res = dfs(cur.left) if cur.left else True
            # 判断右子树是否平衡
            right_res = dfs(cur.right) if cur.right else True
            
            # 最终判断 当前子树平衡并且左右子树平衡当前二叉树才为平衡二叉树
            return abs(left_dep - right_dep) <= 1 and left_res and right_res  

        if not root: return True
        return dfs(root)

    def maxDepth(self, root):
        if not root: return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1

```

## 6、 二叉搜索树的第k大节点

原题地址：[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

解题思路：考察二叉搜索树特性和二叉树中序遍历

 二叉搜索树左中右遍历为小中大，因此把右节点看成左节点，按照中序遍历的变形，进行遍历k次，后直接返回对应值即可

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        stack = []
        cur = root
        while stack or cur:
            while cur:
                stack.append(cur)
                cur = cur.right
            item = stack.pop()
            k -= 1
            if k == 0: return item.val
            cur = item.left
```

## 7、二叉搜索树与双向链表

原题地址：[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

```
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。
要求不能创建任何新的节点，只能调整树中节点指针的指向。
```

解题思路：

先建立一个哨兵节点pre，利用dfs遍历处理，主要处理cur节点。

注意最后要把首尾节点进行连接

```python
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# -- BEGIN --
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(cur):
            if not cur: return
            dfs(cur.left)
            # 处理中间cur节点
            if self.pre:
                self.pre.right = cur
                cur.left = self.pre
            else:
                self.head = cur
            self.pre = cur
            dfs(cur.right)

        if not root: return
        self.pre = None
        dfs(root)
        # 遍历拼接完毕，构建首尾连接，self.pre为最后一个遍历的节点，
        self.head.left = self.pre
        self.pre.right = self.head
        return self.head
# -- END --

# 用于debug使用，输出最终结果
def list2arr(root):
    result = []
    my_set = set()
    cur = root
    while cur and cur not in my_set:
        my_set.add(cur)
        result.append(cur.val)
        cur = cur.right
    return result


if __name__ == '__main__':
    a = Node(4)
    b = Node(2)
    c = Node(5)
    d = Node(1)
    e = Node(3)

    a.left = b
    a.right = c

    b.left = d
    b.right = e
    res = Solution().treeToDoublyList(a)
    print(list2arr(res))
```

